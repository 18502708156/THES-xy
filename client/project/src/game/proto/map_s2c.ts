// Generated by sprotodump. DO NOT EDIT!

namespace Sproto { 
	export class champion_shows {
		public shows: number[]; // tag 0
		public job: number; // tag 1
		public sex: number; // tag 2
		public id: number; // tag 3
		public name: string; // tag 4
		public serverid: number; // tag 5
		public guildid: number; // tag 6
		public guildname: string; // tag 7
		public level: number; // tag 8
	}

	function _decode_champion_shows(d: SprotoTypeDeserialize) {
		let o = new champion_shows;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.shows = d.ria ();
				break;
			case 1:
				o.job = d.ri ();
				break;
			case 2:
				o.sex = d.ri ();
				break;
			case 3:
				o.id = d.ri ();
				break;
			case 4:
				o.name = d.rs ();
				break;
			case 5:
				o.serverid = d.ri ();
				break;
			case 6:
				o.guildid = d.ri ();
				break;
			case 7:
				o.guildname = d.rs ();
				break;
			case 8:
				o.level = d.ri ();
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_champion_shows(self: champion_shows, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 9);

		if (self.shows != undefined) {
			se.wia (self.shows, 0);
		}

		if (self.job != undefined) {
			se.wi (self.job, 1);
		}

		if (self.sex != undefined) {
			se.wi (self.sex, 2);
		}

		if (self.id != undefined) {
			se.wi (self.id, 3);
		}

		if (self.name != undefined) {
			se.ws (self.name, 4);
		}

		if (self.serverid != undefined) {
			se.wi (self.serverid, 5);
		}

		if (self.guildid != undefined) {
			se.wi (self.guildid, 6);
		}

		if (self.guildname != undefined) {
			se.ws (self.guildname, 7);
		}

		if (self.level != undefined) {
			se.wi (self.level, 8);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["champion_shows"] = {en: _encode_champion_shows, de: _decode_champion_shows}
	export class map_player {
		public id: number; // tag 0
		public x: number; // tag 1
		public y: number; // tag 2
		public name: string; // tag 3
		public level: number; // tag 4
		public job: number; // tag 5
		public sex: number; // tag 6
		public power: number; // tag 7
		public shows: number[]; // tag 8
		public status: number; // tag 9
		public guildid: number; // tag 10
		public guildname: string; // tag 11
		public serverid: number; // tag 12
	}

	function _decode_map_player(d: SprotoTypeDeserialize) {
		let o = new map_player;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.id = d.ri ();
				break;
			case 1:
				o.x = d.ri ();
				break;
			case 2:
				o.y = d.ri ();
				break;
			case 3:
				o.name = d.rs ();
				break;
			case 4:
				o.level = d.ri ();
				break;
			case 5:
				o.job = d.ri ();
				break;
			case 6:
				o.sex = d.ri ();
				break;
			case 7:
				o.power = d.ri ();
				break;
			case 8:
				o.shows = d.ria ();
				break;
			case 9:
				o.status = d.ri ();
				break;
			case 10:
				o.guildid = d.ri ();
				break;
			case 11:
				o.guildname = d.rs ();
				break;
			case 12:
				o.serverid = d.ri ();
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_map_player(self: map_player, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 13);

		if (self.id != undefined) {
			se.wi (self.id, 0);
		}

		if (self.x != undefined) {
			se.wi (self.x, 1);
		}

		if (self.y != undefined) {
			se.wi (self.y, 2);
		}

		if (self.name != undefined) {
			se.ws (self.name, 3);
		}

		if (self.level != undefined) {
			se.wi (self.level, 4);
		}

		if (self.job != undefined) {
			se.wi (self.job, 5);
		}

		if (self.sex != undefined) {
			se.wi (self.sex, 6);
		}

		if (self.power != undefined) {
			se.wi (self.power, 7);
		}

		if (self.shows != undefined) {
			se.wia (self.shows, 8);
		}

		if (self.status != undefined) {
			se.wi (self.status, 9);
		}

		if (self.guildid != undefined) {
			se.wi (self.guildid, 10);
		}

		if (self.guildname != undefined) {
			se.ws (self.guildname, 11);
		}

		if (self.serverid != undefined) {
			se.wi (self.serverid, 12);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["map_player"] = {en: _encode_map_player, de: _decode_map_player}
	export class sc_map_enter_request {
		public mapid: number; // tag 0
		public x: number; // tag 1
		public y: number; // tag 2
		public myself: map_player; // tag 3
		public entitylist: map_player[]; // tag 4
	}

	function _decode_sc_map_enter_request(d: SprotoTypeDeserialize) {
		let o = new sc_map_enter_request;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.mapid = d.ri ();
				break;
			case 1:
				o.x = d.ri ();
				break;
			case 2:
				o.y = d.ri ();
				break;
			case 3:
				o.myself = d.ro("map_player");
				break;
			case 4:
				o.entitylist = d.roa("map_player");
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_sc_map_enter_request(self: sc_map_enter_request, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 5);

		if (self.mapid != undefined) {
			se.wi (self.mapid, 0);
		}

		if (self.x != undefined) {
			se.wi (self.x, 1);
		}

		if (self.y != undefined) {
			se.wi (self.y, 2);
		}

		if (self.myself != undefined) {
			se.wo ("map_player", self.myself, 3);
		}

		if (self.entitylist != undefined) {
			se.woa ("map_player", self.entitylist, 4);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["sc_map_enter_request"] = {en: _encode_sc_map_enter_request, de: _decode_sc_map_enter_request}
	export class sc_map_maincity_info_request {
		public championid: number; // tag 0
		public charismaNum: number; // tag 1
		public channelid: number; // tag 2
		public worship: number; // tag 3
		public shows: champion_shows; // tag 4
		public people: number; // tag 5
	}

	function _decode_sc_map_maincity_info_request(d: SprotoTypeDeserialize) {
		let o = new sc_map_maincity_info_request;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.championid = d.ri ();
				break;
			case 1:
				o.charismaNum = d.ri ();
				break;
			case 2:
				o.channelid = d.ri ();
				break;
			case 3:
				o.worship = d.ri ();
				break;
			case 4:
				o.shows = d.ro("champion_shows");
				break;
			case 5:
				o.people = d.ri ();
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_sc_map_maincity_info_request(self: sc_map_maincity_info_request, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 6);

		if (self.championid != undefined) {
			se.wi (self.championid, 0);
		}

		if (self.charismaNum != undefined) {
			se.wi (self.charismaNum, 1);
		}

		if (self.channelid != undefined) {
			se.wi (self.channelid, 2);
		}

		if (self.worship != undefined) {
			se.wi (self.worship, 3);
		}

		if (self.shows != undefined) {
			se.wo ("champion_shows", self.shows, 4);
		}

		if (self.people != undefined) {
			se.wi (self.people, 5);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["sc_map_maincity_info_request"] = {en: _encode_sc_map_maincity_info_request, de: _decode_sc_map_maincity_info_request}
	export class sc_map_other_enter_request {
		public entity: map_player; // tag 0
		public mapid: number; // tag 1
	}

	function _decode_sc_map_other_enter_request(d: SprotoTypeDeserialize) {
		let o = new sc_map_other_enter_request;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.entity = d.ro("map_player");
				break;
			case 1:
				o.mapid = d.ri ();
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_sc_map_other_enter_request(self: sc_map_other_enter_request, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 2);

		if (self.entity != undefined) {
			se.wo ("map_player", self.entity, 0);
		}

		if (self.mapid != undefined) {
			se.wi (self.mapid, 1);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["sc_map_other_enter_request"] = {en: _encode_sc_map_other_enter_request, de: _decode_sc_map_other_enter_request}
	export class sc_map_other_fly_request {
		public id: number; // tag 0
		public x: number; // tag 1
		public y: number; // tag 2
		public mapid: number; // tag 3
	}

	function _decode_sc_map_other_fly_request(d: SprotoTypeDeserialize) {
		let o = new sc_map_other_fly_request;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.id = d.ri ();
				break;
			case 1:
				o.x = d.ri ();
				break;
			case 2:
				o.y = d.ri ();
				break;
			case 3:
				o.mapid = d.ri ();
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_sc_map_other_fly_request(self: sc_map_other_fly_request, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 4);

		if (self.id != undefined) {
			se.wi (self.id, 0);
		}

		if (self.x != undefined) {
			se.wi (self.x, 1);
		}

		if (self.y != undefined) {
			se.wi (self.y, 2);
		}

		if (self.mapid != undefined) {
			se.wi (self.mapid, 3);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["sc_map_other_fly_request"] = {en: _encode_sc_map_other_fly_request, de: _decode_sc_map_other_fly_request}
	export class sc_map_other_leave_request {
		public id: number; // tag 0
		public mapid: number; // tag 1
	}

	function _decode_sc_map_other_leave_request(d: SprotoTypeDeserialize) {
		let o = new sc_map_other_leave_request;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.id = d.ri ();
				break;
			case 1:
				o.mapid = d.ri ();
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_sc_map_other_leave_request(self: sc_map_other_leave_request, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 2);

		if (self.id != undefined) {
			se.wi (self.id, 0);
		}

		if (self.mapid != undefined) {
			se.wi (self.mapid, 1);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["sc_map_other_leave_request"] = {en: _encode_sc_map_other_leave_request, de: _decode_sc_map_other_leave_request}
	export class sc_map_other_move_request {
		public id: number; // tag 0
		public x: number; // tag 1
		public y: number; // tag 2
		public mapid: number; // tag 3
	}

	function _decode_sc_map_other_move_request(d: SprotoTypeDeserialize) {
		let o = new sc_map_other_move_request;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.id = d.ri ();
				break;
			case 1:
				o.x = d.ri ();
				break;
			case 2:
				o.y = d.ri ();
				break;
			case 3:
				o.mapid = d.ri ();
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_sc_map_other_move_request(self: sc_map_other_move_request, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 4);

		if (self.id != undefined) {
			se.wi (self.id, 0);
		}

		if (self.x != undefined) {
			se.wi (self.x, 1);
		}

		if (self.y != undefined) {
			se.wi (self.y, 2);
		}

		if (self.mapid != undefined) {
			se.wi (self.mapid, 3);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["sc_map_other_move_request"] = {en: _encode_sc_map_other_move_request, de: _decode_sc_map_other_move_request}
	export class sc_map_player_status_request {
		public id: number; // tag 0
		public status: number; // tag 1
		public mapid: number; // tag 2
	}

	function _decode_sc_map_player_status_request(d: SprotoTypeDeserialize) {
		let o = new sc_map_player_status_request;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.id = d.ri ();
				break;
			case 1:
				o.status = d.ri ();
				break;
			case 2:
				o.mapid = d.ri ();
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_sc_map_player_status_request(self: sc_map_player_status_request, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 3);

		if (self.id != undefined) {
			se.wi (self.id, 0);
		}

		if (self.status != undefined) {
			se.wi (self.status, 1);
		}

		if (self.mapid != undefined) {
			se.wi (self.mapid, 2);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["sc_map_player_status_request"] = {en: _encode_sc_map_player_status_request, de: _decode_sc_map_player_status_request}
	export class sc_map_player_update_request {
		public id: number; // tag 0
		public mapid: number; // tag 1
		public player: map_player; // tag 2
	}

	function _decode_sc_map_player_update_request(d: SprotoTypeDeserialize) {
		let o = new sc_map_player_update_request;
		let t = -1;
		while (-1 != (t = d.rt())) {
			switch (t) {
			case 0:
				o.id = d.ri ();
				break;
			case 1:
				o.mapid = d.ri ();
				break;
			case 2:
				o.player = d.ro("map_player");
				break;
			default:
				d.nod ();
				break;
			}
		}
		return o
	}

	function _encode_sc_map_player_update_request(self: sc_map_player_update_request, st: Sproto.SprotoStream) {
		let se = SprotoCore.GetSerialize(st, 3);

		if (self.id != undefined) {
			se.wi (self.id, 0);
		}

		if (self.mapid != undefined) {
			se.wi (self.mapid, 1);
		}

		if (self.player != undefined) {
			se.wo ("map_player", self.player, 2);
		}

		return SprotoCore.CloseSerialize(se);
	}

	ALL_DICT["sc_map_player_update_request"] = {en: _encode_sc_map_player_update_request, de: _decode_sc_map_player_update_request}
}

